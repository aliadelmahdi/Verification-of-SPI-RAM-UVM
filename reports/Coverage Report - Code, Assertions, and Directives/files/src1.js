var g_data = {"name":"./design/SPI_design/Designer RTL/SPI_slave.v","src":"`ifndef SPI_SLAVE_SV\n`define SPI_SLAVE_SV\n\nmodule SPI_slave (\n  /*--------------Inputs--------------*/\n    input  MOSI,        /* the serial date sent from the master */\n    input  SS_n,        /* start and end communication from master side */\n    input  [7:0]tx_data,/* the data to write in the memory */\n    input  tx_valid,    /* the signal dedicate that tx_data is ready to covert from parallel to serial by slave*/\n    input  clk,         /*  clock signal input */\n    input  arst_n,      /*  active low synchronous reset */\n  /*--------------outputs-------------*/\n    output reg MISO,         /* the serial data sent to the master */\n    output reg [9:0]rx_data, /* the data which is read from the memory */\n    output reg rx_valid      /* the signal dedicates that rx_data coverted to parallel by slave and ready for memory */ \n);  \n  /*------FSM States Declaration------*/ \n    parameter IDLE       = 3'b000;\n    parameter CHK_CMD    = 3'b001;\n    parameter WRITE      = 3'b010;\n    parameter READ_ADD   = 3'b011;\n    parameter READ_DATA  = 3'b100;\n    \n  /* Xilinx Vivado's Attribute FSM Encoding Method (Gray, One_Hot, Sequential) */\n    (* fsm_encoding = \"sequential\" *)    /* after analysis, Sequential has the best slag time after implementation */\n  /*--------internal signals----------*/ \n    reg [2:0]CS,NS;         /* Current and Next States */\n    reg [3:0]rx_counter;    /* to access the rx_data bus (8-bit) during converting from serial to parallel */  \n    reg [3:0]tx_counter;    /* to access the tx_data bus (8-bit) during converting from serial to parallel */  \n    reg rd_addr_hold;       /* Hold read address */\n  /*------------State memory----------*/ \n  always @(posedge clk ) begin\n    if(~arst_n)begin\n        CS <= IDLE;\n    end else\n        CS <= NS;\n  end\n  /*----------Next State Logic--------*/\n  always @(*) begin\n    case (CS)\n        IDLE :begin\n            if(SS_n)\n                NS = IDLE;\n            else\n                NS = CHK_CMD;\n        end \n        CHK_CMD : begin\n            /* the master opens the communication to the slave */\n            if(~SS_n) begin\n                /* if MOSI is low, operation will be write */ \n                if(~MOSI)\n                    NS = WRITE;\n                /* if MOSI is high, operation will be read */ \n                else begin\n                    /* if the read addr is held, the next is read the data */\n                    if(rd_addr_hold)\n                        NS = READ_DATA;\n                    /* if the read addr isn't held, the next is read address */\n                    else\n                        NS = READ_ADD;\n                end \n            end\n            /* the master ends the communication to the slave */\n            else  \n                NS = IDLE;\n        end\n        WRITE : begin\n            /* the master opens the communication to the slave */\n            if(~SS_n) begin\n                NS = WRITE;\n            end\n            /* the master ends the communication to the slave */\n            else  \n                NS = IDLE;\n        end\n        READ_ADD : begin\n            /* the master opens the communication to the slave */\n            if(~SS_n) begin\n                NS = READ_ADD;\n            end\n            /* the master ends the communication to the slave */\n            else  \n                NS = IDLE;\n        end\n        READ_DATA : begin\n            /* the master opens the communication to the slave */\n            if(~SS_n) \n                NS = READ_DATA;\n            /* the master ends the communication to the slave */\n            else  \n                NS = IDLE;\n        end\n        default:  NS = IDLE;\n    endcase\n  end\n  /*----------Output logic----------*/ \n  always @(posedge clk ) begin\n    if(~arst_n)begin\n        MISO             <= 0;\n        rx_data          <= 0;\n        rx_valid         <= 0;\n        rd_addr_hold     <= 0;\n        rx_counter       <= 0;\n        tx_counter       <= 0;\n    end\n    case (CS)\n        IDLE :begin\n            rx_data  <= 0;\n            rx_valid <= 0;\n            rx_counter  <= 0;\n            tx_counter  <= 0;\n            if(tx_valid)\n                MISO <= tx_data[0]; // Fixed\n            else\n                MISO <= 0;\n        end \n        CHK_CMD:begin\n            MISO     <= 0;\n            rx_data  <= 0;\n            rx_valid <= 0;\n            rx_counter  <= 0;\n            tx_counter  <= 0;\n        end\n        WRITE:begin\n            if(rx_counter<10)begin\n                rx_data[9-rx_counter] <= MOSI;\n                rx_counter <= rx_counter + 1;\n                rx_valid <= 0;\n            end else begin\n                rx_valid <= 1;\n                rx_counter <= 0;\n            end\n        end\n        READ_ADD:begin\n            if(rx_counter<10)begin\n                rx_data[9-rx_counter] <= MOSI;\n                rx_counter <= rx_counter + 1;\n            end else begin\n                rx_valid <= 1;\n                rd_addr_hold <=1;\n                rx_counter <= 0;\n            end\n        end\n        READ_DATA:begin\n            if(rx_counter<10)begin\n                rx_data[9-rx_counter] <= MOSI;\n                rx_counter <= rx_counter + 1;\n            end else begin\n                rx_valid <= 1;\n                /* Convert the read data from parallel to serial */ \n                if(tx_valid)begin\n                    if(tx_counter<8)begin\n                        MISO <= tx_data[7-tx_counter]; // Fixed\n                        tx_counter <= tx_counter + 1;\n                        if (tx_counter == 7)\n                            rd_addr_hold <= 0;\n                    end else begin\n                        MISO <= 0;\n                        rx_counter   <= 0;\n                        tx_counter   <= 0;\n                        rd_addr_hold <= 0;\n                        rx_valid <= 0;\n                    end\n                end\n            end\n        end\n        default:begin\n          MISO <= 0;\n          rx_data <= 0;\n          rx_valid <= 0;\n          tx_counter <=0;\n          rx_counter <=0;\n        end \n    endcase\n  end\nendmodule\n\n`endif // SPI_SLAVE_SV\n","lang":"verilog"};
processSrcData(g_data);