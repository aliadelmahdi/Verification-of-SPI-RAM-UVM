var g_data = {"name":"top/top.sv","src":"import uvm_pkg::*;\nimport SPI_env_pkg::*;\nimport SPI_test_pkg::*;\nimport shared_pkg::*; // For enums and parameters\n`include \"spi_defines.svh\" // For macros\n`timescale `TIME_UNIT / `TIME_PRECISION\n\nmodule tb_top;\n    bit clk;\n    // Clock Generation\n    initial begin\n        clk = `LOW;\n        forever #(`CLK_PERIOD/2) clk = ~ clk;\n    end\n\n    SPI_env env_instance; // Instantiate the SPI enviroment\n    SPI_test test; // Instantiate the SPI test\n     \n    // Instantiate the interface\n    SPI_if spi_if (clk);\n	logic [MEM_WIDTH-1:0] tx_data; // tx_data\n    logic tx_valid;\n      SPI_slave #(\n        .IDLE(spi_if.IDLE),\n        .CHK_CMD(spi_if.CHK_CMD),\n        .WRITE(spi_if.WRITE),\n        .READ_ADD(spi_if.READ_ADD),\n        .READ_DATA(spi_if.READ_DATA)\n        ) slave (\n        .MOSI(spi_if.MOSI),\n        .SS_n(spi_if.SS_n),\n        .clk(spi_if.clk),\n        .arst_n(spi_if.rst_n),\n        .MISO(spi_if.MISO),\n        .rx_data(spi_if.rx_data),\n        .rx_valid(spi_if.rx_valid),\n        .tx_data(tx_data),\n        .tx_valid(tx_valid)\n    );\n    // RAM_Sync_Single_port instantiation\n    RAM_Sync_Single_port #(\n        .MEM_DEPTH(spi_if.MEM_DEPTH),\n        .ADD_SIZE(spi_if.ADDR_SIZE)\n    ) RAM (\n        .din(spi_if.rx_data),\n        .rx_valid(spi_if.rx_valid),\n        .clk(spi_if.clk),\n        .arst_n(spi_if.rst_n),\n        .dout(tx_data),\n        .tx_valid(tx_valid)\n    );\n    // SPI_slave #(\n    //     .IDLE(spi_if.IDLE),\n    //     .CHK_CMD(spi_if.CHK_CMD),\n    //     .WRITE(spi_if.WRITE),\n    //     .READ_ADD(spi_if.READ_ADD),\n    //     .READ_DATA(spi_if.READ_DATA)\n    //     ) slave (\n    //     .MOSI(spi_if.MOSI),\n    //     .SS_n(spi_if.SS_n),\n    //     .clk(spi_if.clk),\n    //     .arst_n(spi_if.rst_n),\n    //     .MISO(spi_if.MISO),\n    //     .rx_data(spi_if.rx_data),\n    //     .rx_valid(spi_if.rx_valid),\n    //     .tx_data(spi_if.dout),\n    //     .tx_valid(spi_if.tx_valid)\n    // );\n\n    // // RAM_Sync_Single_port instantiation\n    // RAM_Sync_Single_port #(\n    //     .MEM_DEPTH(spi_if.MEM_DEPTH),\n    //     .ADD_SIZE(spi_if.ADDR_SIZE)\n    // ) RAM (\n    //     .din(spi_if.rx_data),\n    //     .rx_valid(spi_if.rx_valid),\n    //     .clk(spi_if.clk),\n    //     .arst_n(spi_if.rst_n),\n    //     .dout(spi_if.dout),\n    //     .tx_valid(spi_if.tx_valid)\n    // );\n\n    ram_golden_model RAM_GLD (spi_if.ram_gld);\n    spi_sys_golden_model #(\n        .MEM_DEPTH(spi_if.MEM_DEPTH),\n        .ADDR_SIZE(spi_if.ADDR_SIZE)\n    ) SYS_GLD (spi_if.sys_gld);\n\n    bind SPI_slave SPI_slave_sva SPI_slave_inst  (\n        .MOSI(MOSI),\n        .SS_n(SS_n),\n        .clk(clk),\n        .rst_n(arst_n),\n        .MISO(MISO),\n        .rx_data(rx_data),\n        .rx_valid(rx_valid),\n        .tx_data(tx_data),\n        .tx_valid(tx_valid),\n        .cs(slave.CS),\n        .rx_counter(rx_counter)\n    );\n    assign spi_if.current_addr_data = RAM.mem[RAM.addr_internal];\n    assign spi_if.current_addr_data_ref = SYS_GLD.mem[SYS_GLD.addr_internal_ref];\n\n    bind RAM_Sync_Single_port SPI_ram_sva RAM_sva_inst (\n        .din(din),\n        .rx_valid(rx_valid),\n        .clk(clk),\n        .rst_n(arst_n),\n        .dout(dout),\n        .tx_valid(tx_valid),\n        .addr_internal(RAM.addr_internal),\n        .current_addr_data(spi_if.current_addr_data)\n    );\n    \n    initial begin\n        uvm_top.set_report_verbosity_level(UVM_MEDIUM); // Set verbosity level\n        uvm_top.finish_on_completion = `DISABLE_FINISH; // Prevent UVM from calling $finish\n        uvm_config_db#(virtual SPI_if)::set(null, \"*\", \"spi_if\", spi_if); // Set SPI interface globally\n        run_test(\"SPI_test\"); // Start the UVM test\n        `uvm_info(\"SEED\", $sformatf(\"Current seed: %0d\", $get_initial_random_seed()), UVM_LOW)\n        $stop; // Stop simulation after test execution\n    end\nendmodule : tb_top","lang":"verilog"};
processSrcData(g_data);