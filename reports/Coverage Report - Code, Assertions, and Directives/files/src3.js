var g_data = {"name":"design/SPI_Assertions/SPI_slave_sva.sv","src":"/*  \n    This assertion file follows the **Verification Plan** numbering  \n    Each section corresponds to a specific verification requirement\n\n    The numbers (e.g., 1, 2.2) match the corresponding test items  \n    from the **Verification Plan** for traceability and clarity\n*/\n`include \"spi_defines.svh\" // For macros\nimport shared_pkg::*; // For enums and parameters\n`timescale `TIME_UNIT / `TIME_PRECISION\n\nmodule SPI_slave_sva(cs,MOSI,SS_n,clk,rst_n,tx_data,tx_valid,MISO,rx_data,rx_valid,rx_counter);\n    \n    input MOSI,clk,rst_n,SS_n,tx_valid;\n    input [MEM_WIDTH-1:0] tx_data;\n\n	input logic MISO,rx_valid;\n	input logic [MEM_WIDTH+1:0] rx_data;\n    input logic [2:0] cs;\n    input logic [3:0] rx_counter;\n    //** 1: Reset Verification **\\\\\n\n    // 1.1 & 1.2: Reset Current State\n    property check_reset;\n            (!rst_n)|=> (  cs == IDLE\n                        // && !MISO\n                        // && !rx_valid\n                        // && rx_data ==0\n                        );\n                      \n    endproperty\n    assert_reset: assert property (@(posedge clk) check_reset)\n        else $error(\"Failed to assert reset, the current state at reset is not IDLE\");\n\n    //** 3: FSM transitions **\\\\\n\n    //aserted => slave not selected\n\n    // 3.1: Transition from IDLE to CHK_CMD\n    property check_idle_to_chk_cmd;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==IDLE && SS_n==SLAVE_SELECTED) |=> (cs == CHK_CMD);\n    endproperty\n\n    assert_idle_to_chk_cmd: assert property (check_idle_to_chk_cmd)\n        else $error(\"Failed to move to CHK_CMD state when slave is selected at IDLE state\");\n\n    // 3.1.1: Transition from IDLE to IDLE\n    property check_idle_to_idle;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==IDLE && SS_n==SLAVE_NOT_SELECTED) |=> (cs == IDLE);\n    endproperty\n\n    assert_idle_to_idle: assert property (check_idle_to_idle)\n        else $error(\"Failed to stay at IDLE state when the slave isn't selected\");\n\n    // 3.2: Transition from CHK_CMD to IDLE\n    property check_chk_cmd_to_idle;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==CHK_CMD && SS_n==SLAVE_NOT_SELECTED) |=> (cs == IDLE);\n    endproperty\n\n    assert_chk_cmd_to_idle: assert property (check_chk_cmd_to_idle)\n        else $error(\"Failed to move to IDLE state when slave isn't selected at CHK_CMD state\");\n\n    // 3.2.1: Transition from CHK_CMD to WRITE\n    property check_chk_cmd_to_write;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==CHK_CMD && SS_n==SLAVE_SELECTED && !MOSI) |=> (cs == WRITE);\n    endproperty\n\n    assert_chk_cmd_to_write: assert property (check_chk_cmd_to_write)\n        else $error(\"Failed to move to WRITE state when slave is selected and MOSI is deasserted at CHK_CMD state\");\n\n    // 3.2.2: Transition from CHK_CMD to READ_DATA\n    property check_chk_cmd_to_read_data;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==CHK_CMD && SS_n==SLAVE_NOT_SELECTED) |=> (cs == READ_DATA);\n    endproperty\n\n    assert_chk_cmd_to_read_data: assert property (check_chk_cmd_to_read_data)\n        else $error(\"Failed to move to READ_DATA state when slave is not selected at CHK_CMD state\");\n\n    // 3.2.3: Transition from CHK_CMD to READ_ADD\n    property check_chk_cmd_to_read_add;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==CHK_CMD && SS_n==SLAVE_NOT_SELECTED) |=> (cs == READ_ADD);\n    endproperty\n\n    assert_chk_cmd_to_read_add: assert property (check_chk_cmd_to_read_add)\n        else $error(\"Failed to move to READ_ADD state when slave is not selected at CHK_CMD state\");\n\n    // 3.3: Transition from READ_ADD to IDLE\n    property check_read_add_to_idle;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==READ_ADD && SS_n==SLAVE_NOT_SELECTED) |=> (cs == IDLE);\n    endproperty\n\n    assert_read_add_to_idle: assert property (check_read_add_to_idle)\n        else $error(\"Failed to move to IDLE state when slave isn't selected at READ_ADD state\");\n\n    // 3.3.1: Transition from READ_ADD to READ_ADD\n    property check_read_add_to_read_add;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==READ_ADD && SS_n==SLAVE_SELECTED) |=> (cs == READ_ADD);\n    endproperty\n\n    assert_read_add_to_read_add: assert property (check_read_add_to_read_add)\n        else $error(\"Failed to stay at READ_ADD state when slave is selected at READ_ADD state\");\n\n     // 3.4: Transition from READ_DATA to IDLE\n    property check_read_data_to_idle;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==READ_DATA && SS_n==SLAVE_NOT_SELECTED) |=> (cs == IDLE);\n    endproperty\n\n    assert_read_data_to_idle: assert property (check_read_data_to_idle)\n        else $error(\"Failed to move to IDLE state from READ_DATA state when the slave is not selected\");\n       \n      // 3.4.1: Transition from READ_DATA to READ_DATA\n    property check_read_data_to_read_data;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==READ_DATA && SS_n==SLAVE_SELECTED) |=> (cs == READ_DATA);\n    endproperty\n\n    assert_read_data_to_read_data: assert property (check_read_data_to_read_data)\n        else $error(\"Failed to stay at READ_DATA state when slave is selected at READ_DATA state\");\n\n    // 3.5: Transition from WRITE to IDLE\n    property check_write_to_idle;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==WRITE && SS_n==SLAVE_NOT_SELECTED) |=> (cs == IDLE);\n    endproperty\n\n    assert_write_to_idle: assert property (check_write_to_idle)\n        else $error(\"Failed to move to IDLE state from WRITE state when the slave is not selected\");\n\n    // 3.5.1: Transition from WRITE to WRITE\n    property check_write_to_write;\n        @(posedge clk) disable iff(!rst_n)\n                (cs==WRITE && SS_n==SLAVE_SELECTED) |=> (cs == WRITE);\n    endproperty\n\n    assert_write_to_write: assert property (check_write_to_write)\n        else $error(\"Failed to stay at WRITE state when slave isn't selected at WRITE state\");\n\n    //** 4: Signals at the FSM states **\\\\\n\n        //asserted => slave not selected\n\n        // 4.1: Signals at IDLE state\n        property check_idle;\n            @(posedge clk) disable iff(!rst_n)\n                    (cs==IDLE) |=> (rx_data == 0 &&\n                                    !rx_valid\n                                    );\n        endproperty\n\n        assert_idle: assert property (check_idle)\n            else $error(\"Mismatch in signals at IDLE state\");\n\n        // 4.2: Signals at CHK_CMD state\n        property check_chk_cmd;\n            @(posedge clk) disable iff(!rst_n)\n                    (cs==CHK_CMD) |=> (!MISO &&\n                                       !rx_valid &&\n                                       rx_data == 0\n                                      );\n        endproperty\n\n        assert_chk_cmd: assert property (check_chk_cmd)\n            else $error(\"Mismatch in signals at CHK_CMD state\");\n\n        //** 5: SPI Slave **\\\\\n\n        //aserted => slave not selected\n\n        // 5.1: Serial to Parallel\n\n        logic [MEM_WIDTH+1:0] mosi_shift, mosi_shift_latched;\n\n        always @(posedge clk or negedge rst_n) begin\n            if (!rst_n) begin\n                mosi_shift <= '0;\n                mosi_shift_latched <= '0;\n            end else if (cs inside {WRITE, READ_ADD, READ_DATA}) begin\n                if (rx_counter < MEM_WIDTH+2)\n                    mosi_shift <= {mosi_shift[MEM_WIDTH:0], MOSI}; // Shift left\n                if (rx_valid && rx_counter == MEM_WIDTH+2)\n                    mosi_shift_latched <= mosi_shift;\n            end\n        end\n\n        property check_serial_to_parallel;\n            @(posedge clk) disable iff (!rst_n)\n            (rx_valid && (cs inside {WRITE, READ_ADD, READ_DATA}) && rx_counter == MEM_WIDTH+2) |=> (rx_data == mosi_shift_latched);\n        endproperty\n\n        assert_serial_to_parallel: assert property (check_serial_to_parallel)\n            else begin\n                $error(\"rx_data does not match accumulated MOSI bits after %0d cycles.\",MEM_WIDTH+2);\n                $display(\"DEBUG -> rx_data = %b, mosi_shift = %b, cs = %b, rx_counter = %0d\", rx_data, mosi_shift, cs, rx_counter);\n            end\n\n        // 5.2: Data is ready\n        property check_rx_valid;\n            @(posedge clk) disable iff(!rst_n)\n                    (rx_counter==10 && cs inside {READ_ADD,READ_DATA,WRITE}) |=> (rx_valid);\n        endproperty\n\n        assert_rx_valid: assert property (check_rx_valid)\n            else begin\n                $error(\"The slave did not assert the rx_vaild when the data was ready\");\n                $display(\"DEBUG -> rx_data = %b,cs = %b, rx_counter = %0d\", rx_data, cs, rx_counter);\n            end   \n\n        // 5.3: Parallel to Serial\n        property check_miso;\n            @(posedge clk) disable iff(!rst_n)\n                $rose(tx_valid) |=> (   MISO === tx_data[MEM_WIDTH-1]\n                                    ##1 MISO === tx_data[MEM_WIDTH-2]\n                                    ##1 MISO === tx_data[MEM_WIDTH-3]\n                                    ##1 MISO === tx_data[MEM_WIDTH-4]\n                                    ##1 MISO === tx_data[MEM_WIDTH-5]\n                                    ##1 MISO === tx_data[MEM_WIDTH-6]\n                                    ##1 MISO === tx_data[MEM_WIDTH-7]\n                                    ##1 MISO === tx_data[MEM_WIDTH-8] );\n        endproperty\n\n        assert_miso: assert property (check_miso)\n            else begin\n                $error(\"The slave failed to convert the 10 bits parallel data coming from the tx_data to serial\");\n                $display(\"DEBUG -> tx_data = %b,cs = %b, tx_valid = %0d, MISO = %0b\", tx_data,cs,tx_valid,MISO);\n            end   \nendmodule","lang":"verilog"};
processSrcData(g_data);