var g_data = {"name":"./design/SPI_Assertions/SPI_ram_sva.sv","src":"`ifndef SPI_RAM_SVA_SV\n`define SPI_RAM_SVA_SV\n\n/*  \n    This assertion file follows the **Verification Plan** numbering  \n    Each section corresponds to a specific verification requirement\n\n    The numbers (e.g., 1, 2.2) match the corresponding test items  \n    from the **Verification Plan** for traceability and clarity\n*/\n\nmodule SPI_ram_sva(\n    input clk,rst_n,rx_valid,\n    input[MEM_WIDTH+1:0]din,\n    input logic [MEM_WIDTH-1:0]dout,\n    input logic tx_valid,\n    input logic [ADDR_SIZE-1:0] addr_internal,\n    input logic [MEM_WIDTH-1:0] current_addr_data\n    );\n    logic [1:0] control_bits;\n    parameter MEM_DEPTH=256;\n    parameter ADDR_SIZE=8;\n    parameter MEM_WIDTH=8;\n    assign control_bits = din[9:8];\n    \n    property check_reset;\n            (!rst_n)|=> ( dout==0\n                        && !tx_valid);\n    endproperty\n\n    assert_check_reset: assert property (@(posedge clk) check_reset)\n        else begin\n        $error(\"Failed to assert reset\");\n        $display(\"dout = %h, tx_valid = %b\", dout, tx_valid);\n        end\n\n    property check_wr_addr_ram;\n        @(posedge clk) disable iff(!rst_n)\n                (rx_valid && control_bits== WR_ADDR) |=> (addr_internal == $past(din[7:0]));\n    endproperty\n\n    assert_wr_addr_ram: assert property (check_wr_addr_ram)\n        else begin\n                $error(\"The RAM failed to store din[7:0] in the internal write address bus when the control bits are WR_ADDR\");\n                $display(\"din[7:0] = %h, addr_internal = %h\", din[7:0], addr_internal); \n            end\n\n    property check_wr_data_ram;\n        @(posedge clk) disable iff(!rst_n)\n                (rx_valid && control_bits==WR_DATA) |=> (current_addr_data === $past(din[7:0]));\n    endproperty\n\n    assert_wr_data_ram: assert property (check_wr_data_ram)\n        else begin\n            $error(\"The RAM failed to store din[7:0] with write address previously held\");\n            $display(\"current_addr_data = %h, din[7:0] = %h\", current_addr_data, $past(din[7:0])); \n        end\n\n    property check_rd_addr_ram;\n        @(posedge clk) disable iff(!rst_n)\n                (rx_valid && control_bits==RD_ADDR) |=> (addr_internal == $past(din[7:0]));\n    endproperty\n\n    assert_rd_addr_ram: assert property (check_rd_addr_ram)\n            else $error(\"The RAM failed to store din[7:0] in the internal read address bus\");\n\n    property check_rd_data_ram;\n        @(posedge clk) disable iff(!rst_n)\n                ( rx_valid && control_bits==RD_DATA) |=> (dout[7:0] === current_addr_data\n                                        && tx_valid);\n    endproperty\n\n    assert_rd_data_ram: assert property (check_rd_data_ram)\n        else begin\n            $error(\"Failed to read from the memory with rd address previously held\");\n            $display(\"dout[7:0]) = %h, mem[addr_internal] = %h tx_valid = %b\", control_bits, current_addr_data,tx_valid);\n             end\n\n    property check_tx_valid;\n        @(posedge clk) disable iff(!rst_n)\n                ( rx_valid && !(control_bits==RD_DATA)) |=> (!tx_valid);\n    endproperty\n\n    assert_tx_valid: assert property (check_tx_valid)\n        else $error(\"Failed to ensure that the RAM deasserts tx valid\");\n\nendmodule : SPI_ram_sva \n\n`endif // SPI_RAM_SVA_SV","lang":"verilog"};
processSrcData(g_data);